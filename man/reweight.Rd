% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reweight.r
\name{reweight}
\alias{reweight}
\title{Reweight a microdata file.}
\usage{
reweight(
  iweights,
  targets,
  target_names,
  tol,
  xmat,
  xlb = 0,
  xub = 50,
  maxiter = 50,
  optlist = NULL,
  method = "auglag",
  quiet = TRUE
)
}
\arguments{
\item{iweights}{Numeric vector of initial household weights, length h.}

\item{targets}{Numeric vector of desired target values, length k.}

\item{target_names}{Character vector of names for targets, length k.}

\item{tol}{Numeric vector of additive tolerances for targets, length k. The
solver will seek to hit the targets, plus or minus tol.}

\item{xmat}{Matrix of data for households, dimension h x k.}

\item{xlb}{Numeric vector of lower bounds for the ratio of new weights to
initial weights. Default is 0.}

\item{xub}{Numeric vector of upper bounds for the ration of new weights to
initial weights. Default is 50.}

\item{maxiter}{Integer value for maximum number of iterations for ipopt;
maxeval for nlopt. Default is 50.}

\item{optlist}{Named list of allowable options:
\href{https://coin-or.github.io/Ipopt/OPTIONS.html}{IPOPT options}
run \code{nloptr::nloptr.print.options()} for \code{nloptr} options.}

\item{method}{"auglag" (default) or "ipopt" (requires installation of ipoptr)}

\item{quiet}{TRUE (default) or FALSE}
}
\value{
A list with the following elements:

\describe{
\item{solver_message}{The message produced by IPOPT. See
\href{https://coin-or.github.io/Ipopt/OUTPUT.html}{IPOPT output}.}
\item{etime}{Elapsed time.}
\item{objective}{The objective function value at
the solution.}
\item{weights}{Numeric vector of new weights.}
\item{targets_df}{Data frame with target names and values, values at the
starting point, values at the solution, tolerances, differences, and percent
differences. The suffix diff indicates the difference from a target and the
suffix pdiff indicates the percent difference from a target.}
\item{result}{List with output from the solver that was used.}
}
}
\description{
Calculate new weights for each household in a microdata file
so that (1) selected variables, weighted with the new weights and summed, hit
or come close to desired targets, and (2) a measure of distortion based on
how much the new weights differ from an initial set of weights is minimized.
}
\details{
\code{reweight} uses the \href{https://coin-or.github.io/Ipopt/}{IPOPT
solver} in the package \code{\link[ipoptr]{ipoptr}}. The problem is set up as
a nonlinear program with constraints. The constraints are the desired
targets. The user can set tolerances around these targets in which case they
are inequality constraints. By default the distortion measure to be minimized
is the sum of squared differences between the ratio of each new weight to the
corresponding initial weight and 1. The user can provide alternative
distortion measures.
}
\examples{
# Example 1: Determine new weights for a simple problem with random data
p <- make_problem(h=30, s=1, k=4)
# we'll have 30 households (30 weights) and 4 targets

# break out needed components and prepare them for reweight
iweights <- p$wh

targets <- as.vector(p$targets)
target_names <- paste0("targ", 1:length(targets))
# the targets created by make_problem are hit exactly when using the initial
# weights so perturb them slightly so that we have to find new weights
set.seed(1234)
noise <- rnorm(n=length(targets), mean = 0, sd = .02)
targets <- targets * (1 + noise)

tol <- .005 * abs(targets)
xmat <- p$xmat
colnames(xmat) <- target_names

res <- reweight(iweights = iweights,
                targets = targets,
                target_names = target_names,
                tol = tol,
                xmat = xmat,
                method="ipopt",
                quiet = FALSE)
res$etime
res$objective_unscaled
res$targets_df

res2 <- reweight(iweights = iweights,
                 targets = targets,
                 target_names = target_names,
                 tol = tol,
                 xmat = xmat,
                 method="auglag",
                 quiet = TRUE)
res2$etime
res2$objective_unscaled
res2$targets_df

# Example 2: Determine new weights for a small problem using ACS data
library(tidyverse)
data(acsbig)
data(acs_targets)
# let's focus on income group 5 and create and then try to hit targets for:
#    number of records (nrecs -- to be created based on the weight, pwgtp)
#    personal income (pincp)
#    wages (wagp)
#    number of people with wages (wagp_nnz -- to be created)
#    supplemental security income (ssip)
#    number of people with supplemental security income (ssip_nnz -- to
#       be created)
# we also need to get pwgtp - the person weight for each record, which
#       will be our initial weight
# for each "number of" variable we need to create an indicator variable that
# defines whether it is true for that record

# get the data and prepare it
data_df <- acsbig \%>\%
  filter(incgroup == 5) \%>\%
  select(pwgtp, pincp, wagp, ssip) \%>\%
  # create the indicator variables
  mutate(nrecs = 1, # indicator used for number of records
         wagp_nnz = (wagp != 0) * 1.,
         ssip_nnz = (ssip != 0) * 1.)
data_df # 10,000 records

# prepare targets: in practice we would get them from an external source but
# in this case we'll get actual sums on the file and perturb them randomly
# so that targets differ from initial sums
set.seed(1234)
targets_df <- data_df \%>\%
  pivot_longer(-pwgtp) \%>\%
  mutate(wtd_value = value * pwgtp) \%>\%
  group_by(name) \%>\%
  summarise(wtd_value = sum(wtd_value), .groups = "drop") \%>\%
  mutate(target = wtd_value * (1 + rnorm(length(.), mean=0, sd=.02)))
# in practice we'd make sure that targets make sense (e.g., not negative)
targets_df

iweights <- data_df$pwgtp
targets <- targets_df$target
target_names <- targets_df$name

tol <- .005 * abs(targets) # use 0.5\% as our tolerance
xmat <- data_df \%>\%
  # important that columns be in the same order as the targets
  select(all_of(target_names)) \%>\%
  as.matrix

# You can write ipopt output to a text file and even monitor results of a
# long-running optimization by opening the file with a text editor, as long
# as the editor does not lock the file for writing. Normally you would specify
# the path to the output file in a location on your system but for this example
# we'll use a temporary file, which we'll call tfile.
tfile <- tempfile("tfile",fileext=".txt")
opts <- list(output_file = tfile,
             file_print_level = 5,
             linear_solver = "mumps")

res <- reweight(iweights = iweights, targets = targets,
                target_names = target_names, tol = tol,
                xmat = xmat,
                maxiter = 20,
                optlist = opts,
                method = "ipopt",
                quiet = TRUE) # we'll write progress to tfile so quiet is nice
names(res)
res$solver_message
res$etime
res$objective_unscaled
res$targets_df

# Normally you would examine the optimization output file in a text editor
# For this example, we display it in the console:
writeLines(readLines(tfile))
unlink(tfile) # delete the temporary file in this example

res2 <- reweight(iweights = iweights,
                 targets = targets,
                 target_names = target_names,
                 tol = tol,
                 xmat = xmat,
                 method = "auglag",
                 maxiter = 1500,
                 quiet = FALSE)
names(res2)
res2$solver_message
res2$etime
res2$objective_unscaled
res2$targets_df

}
