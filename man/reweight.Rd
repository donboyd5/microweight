% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reweight.r
\name{reweight}
\alias{reweight}
\title{Reweight a microdata file.}
\usage{
reweight(
  iweights,
  xmat,
  targets,
  tol,
  xlb = 0,
  xub = 50,
  maxiter = 50,
  optlist = NULL,
  method = "auglag",
  quiet = TRUE
)
}
\arguments{
\item{iweights}{Initial household weights, numeric vector length h.}

\item{xmat}{Data for households. Matrix with 1 row per household and 1 column
per characteristic (h x k matrix). Columns can be named.}

\item{targets}{Targeted values, 1 per characteristic. Numeric vector length
k. Can be a named vector. If named, names must match those of \code{xmat}.}

\item{tol}{Additive tolerances for targets, 1 per characteristic. Numeric
vector length k. The solver will seek to hit the targets, plus or minus
tol.}

\item{xlb}{Lower bounds for the ratio of new weights to initial weights. Can
be a vector of 1 weight per household or a scalar that will be used for all
households. Default is 0.}

\item{xub}{Upper bounds for the ratio of new weights to initial weights. Can
be a vector of 1 weight per household or a scalar that will be used for all
households. Default is 50.}

\item{maxiter}{Integer value for maximum number of iterations for ipopt;
maxeval for nlopt. Default is 50.}

\item{optlist}{Named list of allowable options:
\href{https://coin-or.github.io/Ipopt/OPTIONS.html}{IPOPT options} run
\code{nloptr::nloptr.print.options()} for \code{nloptr} options.}

\item{method}{=c("auglag", "ipopt"). auglag is default. ipopt requires
installation of \code{ipoptr}, which can be difficult. See details.}

\item{quiet}{TRUE (default) or FALSE.}
}
\value{
A list with the following elements:

\describe{
\item{solver_message}{The message produced by IPOPT. See
\href{https://coin-or.github.io/Ipopt/OUTPUT.html}{IPOPT output}.}
\item{etime}{Elapsed time.}
\item{objective}{The objective function value at
the solution.}
\item{weights}{Numeric vector of new weights.}
\item{targets_df}{Data frame with target names and values, values at the
starting point, values at the solution, tolerances, differences, and percent
differences. The suffix diff indicates the difference from a target and the
suffix pdiff indicates the percent difference from a target.}
\item{result}{List with output from the solver that was used.}
}
}
\description{
Calculate new weights for each household in a microdata file
so that (1) selected variables, weighted with the new weights and summed, hit
or come close to desired targets, and (2) a measure of distortion based on
how much the new weights differ from an initial set of weights is minimized.
}
\details{
\code{reweight} uses the \href{https://coin-or.github.io/Ipopt/}{IPOPT
solver} in the package \code{\link[ipoptr]{ipoptr}}. The problem is set up as
a nonlinear program with constraints. The constraints are the desired
targets. The user can set tolerances around these targets in which case they
are inequality constraints. By default the distortion measure to be minimized
is the sum of squared differences between the ratio of each new weight to the
corresponding initial weight and 1. The user can provide alternative
distortion measures.
}
\examples{
# Example 2: Determine new weights for a small problem using ACS data
library(tidyverse)
data(acs)
data(acs_targets)
# let's focus on income group 5 and create and then try to hit targets for:
#    number of records (nrecs -- to be created based on the weight, pwgtp)
#    personal income (pincp)
#    wages (wagp)
#    number of people with wages (wagp_nnz -- to be created)
#    supplemental security income (ssip)
#    number of people with supplemental security income (ssip_nnz -- to
#       be created)
# we also need to get pwgtp - the person weight for each record, which
#       will be our initial weight
# for each "number of" variable we need to create an indicator variable that
# defines whether it is true for that record

# get the data and prepare it
data_df <- acs \%>\%
  filter(incgroup == 5) \%>\%
  select(pwgtp, pincp, wagp, ssip) \%>\%
  # create the indicator variables
  mutate(nrecs = 1, # indicator used for number of records
         wagp_nnz = (wagp != 0) * 1.,
         ssip_nnz = (ssip != 0) * 1.)
data_df # 1,000 records

iweights <- data_df$pwgtp # initial weights

# prepare targets: in practice we would get them from an external source but
# in this case we'll get actual sums on the file and perturb them randomly
# so that we will need new weights to hit these targets.
set.seed(1234)
targets_df <- data_df \%>\%
  pivot_longer(-pwgtp) \%>\%
  mutate(wtd_value = value * pwgtp) \%>\%
  group_by(name) \%>\%
  summarise(wtd_value = sum(wtd_value), .groups = "drop") \%>\%
  mutate(target = wtd_value * (1 + rnorm(length(.), mean=0, sd=.02)))
# in practice we'd make sure that targets make sense (e.g., not negative)
targets_df

targets <- targets_df$target
names(targets) <- targets_df$name
targets

tol <- .005 * abs(targets) # use 0.5\% as our tolerance

# Prepare the matrix of characteristics of each household. These characteristics must correspond to the targets. Columns must
# either be in the same order as the targets, or must have the same names.
xmat <- data_df \%>\%
  # important that columns be in the same order as the targets
  select(all_of(names(targets))) \%>\%
  as.matrix

res <- reweight(iweights = iweights,
                 xmat = xmat,
                 targets = targets,
                 tol = tol)
res$etime
res$objective_unscaled
res$targets_df

#' \dontrun{
# This example is not run because it uses `ipoptr`, which is not a requirement for `microweight`.

# You can write ipopt output to a text file and even monitor results of a
# long-running optimization by opening the file with a text editor, as long
# as the editor does not lock the file for writing. Normally you would specify
# the path to the output file in a location on your system but for this example
# we'll use a temporary file, which we'll call tfile.
tfile <- tempfile("tfile",fileext=".txt")
opts <- list(output_file = tfile,
             file_print_level = 5,
             linear_solver = "ma27")

res2 <- reweight(iweights = iweights,
                xmat = xmat,
                targets = targets,
                tol = tol,
                maxiter = 20,
                optlist = opts,
                method = "ipopt",
                quiet = TRUE) # we'll write progress to tfile so quiet is nice
names(res2)
res2$solver_message
res2$etime
res2$objective_unscaled
res2$targets_df

# Normally you would examine the optimization output file in a text editor
# For this example, we display it in the console:
writeLines(readLines(tfile))
unlink(tfile) # delete the temporary file in this example
}

}
